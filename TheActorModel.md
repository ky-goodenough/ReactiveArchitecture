# The Actor Model

We've talked about reactive programming techniques and how they can be used to build systems that are reactive or perhaps build systems that aren't reactive. One of the tools that I wanted to talk about specifically, which is a reactive programming tool, is something called the actor model. The actor model is a programming paradigm that supports the construction of reactive systems. Again like with any other reactive programming tool, just because you use the actor model doesn't necessarily mean you have built a reactive system. You still have to keep those high level architectural goals in mind. You have to build according to the reactive principles. However it does provide facilities to very readily support all of the reactive principles. First off, the actor model by its very nature is message driven. When you build systems using the actor model all communication between actors is done using asynchronous non-blocking messages. That's one checkbox that we can check on the reactive principles. It also provides abstractions that give us elasticity and resilience. Because of the fact that it is message driven it makes it very easy to make it elastic and to make it resilient. So there are a number of facilities inside of the actor model that allow you to do that. That includes things such as location transparency (is one of the big ones) and we'll talk about that shortly as well. Because of the fact that it is message driven, it is elastic, it is resilient, it can be used to build responsive software. On the JVM we have something called Akka which implements the actor model. That is a an implementation of the actor model that we can use to build reactive systems. It is the foundation of other reactive tools such as Lagom and Akka Streams as well. Just to give you a little bit of history of the actor model, if you're interested the actor model was not created by Akka. It actually has a very long history. It was created in the early 70s by a man named Carl Hewitt. The basic idea is that the principle abstraction is encapsulating all computation inside of an actor. In the 70s the idea wasn't necessarily taken to its full extent due to hardware constraints and things like that. However later languages evolved that we're allowed to use it better because of newer hardware. Now as we're moving into the more distributed environment of the the modern world the actor model is making a bit of a resurgence as people realize that it is actually very valuable for building distributed systems. So what are some of the fundamental concepts of the actor model? First, is that all computation and occurs inside of an actor. At some point in your application you are gonna have one or more actors--ideally more than one, a single actor is not actually that useful--so you will have some combination of actors. All your computation will occur inside of one of those actors or across many of those actors. Each of those actors is addressable, it has a unique address. And those actors communicate only through asynchronous messages. That is the only way they can talk to each other. Now the message driven nature of actors provides us something that we call location transparency. Our actors communicate with the same technique regardless of location. This means that local versus remote is mostly about configuration. If you look at our little diagram here, we have a couple of green actors and we have a green router. That router can actually just be another actor. But what we have is when you want to send a message to an actor you send it for example to that router. That router is then going to route those messages to some number of routees. In this case we have one routes that is living in the same the same JVM. You can think of the dotted lines as representing a JVM. So you have a green actor that is being routed to but you also have two blue actors which are remote. They live in a separate JVM but they can still act as routees. From the perspective of the original actor, sending the message to the router, he has no idea where that message is gonna go. He's gonna send the message to the router and the router is gonna figure out where it goes. It may go to a local actor or it may go to a remote actor, we don't know. And because of that we have what we call location transparency, which is the original actor sends a message with no knowledge of the location of where that message is going to go. It doesn't use a specific technique to send to a remote actor, there isn't a different API to send a remote actor. The API is identical no matter whether it's sending to a remote actor or a local actor. That is the essence of location transparency. Again local versus remote becomes mostly about configuration. It's about saying that this router can route to these routees. The actual communication mechanisms don't change at all. This enables actors to be both resilient and elastic. The way that it does that is because now we can deploy those actors across multiple pieces of hardware which means they are resilient if one of those pieces of hardware fails. That's okay because we have other ones to fill in the gap. It also allows it to be elastic because if we have a high level of load we can simply add more routees on more pieces of hardware giving us elasticity. Or if we need to scale down for some reason again we can remove some of those remote JVMs. That allows us to scale down so we are elastic at that point. Location transparency shouldn't be confused with transparent remoting. Transparent remoting basically tries to take remote calls and make them look like local calls. Everything looks like a local call even though it may be remote. What this does is it hides the fact that you're making remote calls. As a result it can hide potential failure scenarios. You might have network failures, for example, and because it looks like a local call you won't know whether there's going to be failure or not: you might not think to deal with that possibility. Location transparency, on the other hand, takes the opposite approach. It makes local calls look like remote calls. This basically means you're always assuming that you're making remote calls. Which means you have to assume a remote failure scenario could occur, like network failures and other types of failures. Basically you can't make the assumption that the message is guaranteed to be delivered. You have to assume that there's a possibility of failure. So the actor model is important in many ways. There are many reactive programming tools, we talked about a number of them Futures, Streams, RxJava, RxScala, those kinds of things. Most of them support only some of the reactive principles. They may communicate in an asynchronous, non-blocking way but they don't really have facilities to give you the ability to scale up, scale down or be resilient. You often have to combine different technologies if you want to build a reactive system. You might use your reactive programming tools but then you need to add other things in like load balancers and things like that in order to make sure that you maintain the elasticity and the resilience. The Actor Model provides facilities to support all of their reactive principles: It is message driven by default. The location transparency is there to support elasticity and resilience through distribution. The elasticity and resilience then provide responsiveness under a wide variety of circumstances. Again it is still possible to write a system with the Actor Model and not be reactive. But with the Actor Model, and the tools that are based on it, you're further along the path to success. You have a number of things that you can use just with the Actor Model alone that will get you to building a reactive system. What if we wanted to build a reactive system without actors? How would we do that? It's still completely possible, we're not going to imply that you need the Actor Model in order to build a reactive system. In this diagram we have our services and they are stuck behind the load balancer with some sort of service registry. This gives us location transparency. When we talked to the load balancer we don't know how many machines our services deployed across. We don't know how many instances of the service there are. We don't know where they live. We're just talking to the load balancer. So we get some location transparency through that. We also then add in a message bus. This gives us the ability to communicate using asynchronous, non-blocking messages. It also gives us some location transparency as well. We get that through the message bus. The combination of the load balancer and the message bus give us the ability to be resilient and elastic. We can deploy many copies of our service, whether we're scaling up or scaling down. And we can do that across multiple pieces of hardware. In the event of failure we can recover from that. This gives us all of the things that we need: we've got asynchronous non-blocking messages, we are resilient and elastic, and we can use that to build a responsive system. So we have a reactive system. However the components here are added on rather than being built in. We didn't start with the necessary tools. We had to add all of them in. It requires additional infrastructure: so we've got a service registry, we've got a load balancer, we've got a message bus. All of these things are there in order to provide us what we need to build a reactive system. The final thing is this results in a reactive system or a system that will be reactive at the large scale. It's reactive at the scale of microservices but it's not necessarily reactive within those microservices. That's one of the key differences with the actor model: the actor model can be reactive at the level of actors and actors are within a microservice. You can have many actors within a single microservice. Whereas using these tools you have built something that is reactive at the level of microservices as opposed to internally. It's still possible to build something that is going to be reactive at the level of components inside that service but it gets a lot harder. Whereas with the Actor Model it's very easy to do that. What this boils down to is you can build reactive systems without actors or without the Actor Model but if you start with a very strong foundation like the Actor Model it's going to make a lot of things easier later on.

## Actor model

これまで、リアクティブなプログラミング技術と、それを使ってリアクティブなシステムを構築したり、リアクティブではないシステムを構築したりする方法についてお話してきました。私が特にお話ししたかったのは、リアクティブ・プログラミング・ツールの一つで、アクター・モデルと呼ばれるものです。アクタモデルは、リアクティブなシステムの構築をサポートするプログラミングパラダイムです。他のリアクティブ・プログラミング・ツールと同じように、アクター・モデルを使ったからといって、必ずしもリアクティブ・システムが構築されたとは限りません。高レベルのアーキテクチャ目標を念頭に置いておく必要があります。リアクティブの原則に従って構築しなければなりません。しかし、アクターモデルは、すべてのリアクティブ原則を容易にサポートするための機能を提供しています。まず第一に、アクタモデルはその性質上、メッセージ駆動型です。アクタモデルを使ってシステムを構築する場合、アクタ間のすべての通信は非同期ノンブロッキングメッセージを使って行われます。これは、リアクティブ原則のチェックボックスの1つです。また、アクターモデルは、弾力性と回復力を与える抽象化を提供してくれます。メッセージ駆動なので、弾力性や弾力性を持たせることが非常に簡単にできます。アクターモデルの中には、それを可能にする多くの機能があります。これには、位置情報の透過性（これは大きなものの一つです）などが含まれます。メッセージ駆動であり、弾力性があり、回復力があり、レスポンシブなソフトウェアを構築するために使用することができます。JVM上には、アクタモデルを実装したAkkaと呼ばれるものがあります。これは、リアクティブシステムを構築するために使用できるアクターモデルの実装です。これは、LagomやAkka Streamsのような他のリアクティブツールの基礎となっています。アクタモデルの歴史を少しだけ紹介しておきましょう。アクターモデルの歴史はとても長いのです。70年代初頭にカール・ヒューイットという人によって作られました。基本的な考え方は、アクタの中にすべての計算をカプセル化して抽象化するというものです。70年代には、ハードウェアの制約やそのようなもののために、このアイデアは必ずしも完全には実現されていませんでした。しかし、後になって言語が進化し、新しいハードウェアのおかげで、それをより良く使うことができるようになりました。現代の世界では、より分散化された環境へと移行しているため、アクタモデルは、分散システムを構築する上で非常に価値のあるものであると人々が認識しているため、少しずつ復活しています。では、アクターモデルの基本的なコンセプトとは何でしょうか？まず、すべての計算はアクタの内部で行われます。アプリケーションのどこかの時点で、1つ以上のアクタが必要になります。そのため、いくつかのアクタの組み合わせを持つことになります。すべての計算は、これらのアクタのうちの1つの中で、あるいは多くのアクタにまたがって行われます。これらのアクタはそれぞれアドレス指定可能で、固有のアドレスを持っています。そして、これらのアクタは非同期メッセージを介してのみ通信します。これは、お互いに話すことができる唯一の方法です。アクタのメッセージ駆動の性質は、位置情報の透過性と呼ばれるものを提供してくれます。私たちのアクターは場所に関係なく同じ手法で通信します。これは、ローカルとリモートの違いは、ほとんどが設定に関係していることを意味します。この図を見てください。緑のアクタと緑のルータがあります。このルーターは実際には別のアクターになります。しかし、あるアクターにメッセージを送りたい場合は、例えばそのルーターにメッセージを送ります。ルータはそのメッセージをいくつかのルートにルーティングします。このケースでは、同じJVM内に1つのルートが存在しています。点線はJVMを表していると考えることができます。つまり、緑色のアクタがルーティングされていますが、2つの青色のアクタがリモートにあります。これらのアクタは別のJVMに住んでいますが、ルートとして動作することができます。ルータにメッセージを送信する元のアクタの視点からは、そのメッセージがどこに行くのかはわかりません。彼はルータにメッセージを送信し、ルータはそれがどこに行くのかを把握します。それはローカルアクターに行くかもしれませんし、リモートアクターに行くかもしれませんが、私たちは知りません。これは、元のアクタがメッセージの行き先の場所を知らずにメッセージを送信するというものです。リモートアクターに送信するために特定のテクニックを使用するわけではありませんし、リモートアクターに送信するための異なるAPIもありません。リモートアクターに送信する場合でも、ローカルアクターに送信する場合でも、APIは同じです。これがロケーション透過性の本質です。繰り返しになりますが、ローカルとリモートの違いは、ほとんどが設定に関するものになります。これは、このルータはこれらのルートにルーティングすることができます。実際の通信メカニズムは全く変わりません。これにより、アクターは弾力性と弾力性の両方を持つことができます。これにより、複数のハードウェアにまたがってアクタを展開できるようになり、ハードウェアの1つが故障しても回復力があることを意味します。そのギャップを埋めるために他のものがあるので問題ありません。また、高レベルの負荷がかかった場合には、より多くのハードウェアにルートを追加するだけで、弾力性を持たせることができます。また、何らかの理由でスケールダウンが必要になった場合は、リモートJVMの一部を削除することもできます。これにより、スケールダウンが可能になるので、その時点で弾力性があります。位置情報の透過性と透過的なリモーティングを混同してはいけません。透過的リモーティングは基本的にリモートからのコールを受けて、それをローカルコールのように見せようとします。リモートであっても、すべてがローカルコールのように見えます。これが何をするかというと、リモート通話をしているという事実を隠してしまうということです。その結果、潜在的な障害シナリオを隠すことができます。例えば、ネットワーク障害が発生する可能性がありますが、ローカル通話のように見えるため、障害が発生するかどうかはわかりません。一方、位置情報の透過性は逆のアプローチをとります。これは、ローカル通話をリモート通話のように見せます。これは基本的に、常にリモート通話をしていると仮定していることを意味します。つまり、ネットワーク障害やその他の種類の障害のようなリモート障害シナリオが発生する可能性があることを想定しなければならないということです。基本的に、メッセージの配信が保証されているという仮定はできません。障害が発生する可能性があることを想定しなければなりません。ですから、アクタモデルは様々な意味で重要なのです。リアクティブ・プログラミング・ツールはたくさんありますが、Futures、Streams、RxJava、RxScalaなどがあります。これらのツールのほとんどは、反応性の原理の一部しかサポートしていません。非同期でノンブロッキングな方法で通信することはできますが、スケールアップ、スケールダウン、レジリエンスを提供する機能はありません。リアクティブなシステムを構築するには、多くの場合、異なる技術を組み合わせる必要があります。リアクティブ・プログラミング・ツールを使うかもしれませんが、弾力性と回復力を維持するために、ロードバランサーなどの他のものを追加する必要があります。アクターモデルは、すべてのリアクティブな原則をサポートするための機能を提供します。デフォルトではメッセージ駆動です。位置の透明性は、配布を通じて弾力性と回復力をサポートするためにあります。そして、弾力性と回復力は、様々な状況下での応答性を提供します。ここでも、アクターモデルを使ってシステムを書き、反応しないことは可能です。しかし、アクターモデルとそれをベースにしたツールを使えば、成功への道はさらに開けます。Actor Modelだけでも、リアクティブなシステムを構築するために使えるものがたくさんあります。アクターなしでリアクティブなシステムを構築するとしたらどうでしょうか？どうやってそれを実現するのでしょうか？まだ完全に可能です。リアクティブシステムを構築するためにアクターモデルが必要だとは言いません。この図では、サービスがあり、サービスレジストリのようなものでロードバランサーの後ろに置かれています。これにより、ロケーションの透明性が確保されています。ロードバランサーと話をしても、サービスが何台のマシンにデプロイされているかはわかりません。サービスのインスタンスが何台あるのかもわかりません。サービスのインスタンスが何台あるのかもわからないし、どこに住んでいるのかもわかりません。ロードバランサーと話しているだけです。これで位置情報の透過性を得ることができます。メッセージバスも追加します 非同期でノンブロッキングのメッセージを使って 通信できるようになります また、位置情報の透過性も得られます。これをメッセージバスで実現しています。ロードバランサーとメッセージバスを組み合わせることで、弾力性と弾力性を持たせることができます。スケールアップしてもスケールダウンしても、サービスの多くのコピーを展開することができます。また、複数のハードウェアにまたがってサービスを展開することができます。障害が発生しても、そこから回復することができます。非同期ノンブロッキングメッセージ、回復力と弾力性があり、応答性のあるシステムを構築するためにこれを利用できます。これを使って、反応するシステムを構築することができます。しかし、ここでのコンポーネントは組み込みではなく、追加されたものです。必要なツールから始めたわけではありません。必要なツールをすべて追加しなければなりませんでした。サービスレジストリ、ロードバランサー、メッセージバスなどのインフラを追加する必要があります。これらはすべて、リアクティブなシステムを構築するために必要なものを提供するために存在しています。最終的には、これが結果的にリアクティブなシステム、あるいは大規模でリアクティブなシステムになるということです。マイクロサービスの規模ではリアクティブですが、そのマイクロサービス内では必ずしもリアクティブではありません。これがアクターモデルとの重要な違いの1つで、アクターモデルはアクターのレベルでリアクティブになることができ、アクターはマイクロサービス内に存在します。1つのマイクロサービス内に多くのアクターを持つことができます。一方、これらのツールを使用すると、内部的なものではなく、マイクロサービスのレベルでリアクティブなものを構築することができます。サービス内部のコンポーネントレベルでリアクティブなものを構築することはまだ可能ですが、それは非常に難しくなります。しかし、アクターモデルではそれが非常に簡単にできます。結局のところ、アクターなしでもアクターモデルなしでもリアクティブなシステムを構築することは可能ですが、アクターモデルのような非常に強固な基盤から始めれば、後になってから多くのことが容易になるでしょう。
